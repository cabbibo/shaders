<html>

  <head>
    <style>
      html{margin:0px;background:#fff;overflow:hidden;}
      body{margin:0px;background:#fff;overflow:hidden;}
      #container{ position:absolute; left:0px; top:0px; }
    </style>
  </head>

  <body>


    <script src="lib/jquery.min.js"></script>
    <script src="lib/three.min.js"></script>
    <script src="lib/ScrollControls.js"></script>
    <script src="utils/TextParticles.js"></script>
    <script src="utils/PhysicsRenderer.js"></script>
    <script src="utils/ShaderLoader.js"></script>
    
    <script>
      
      var uniforms;
      var texture;

      var clock;
      var camera, renderer, scene , controls;
      
      var vs, fs;

      var shaderLoader;

      var geometry, material , light;

      var vs_particles , fs_particles;

      var vsTextPosShader;

      var particles;

      var timer = { type:"f" , value:0 }

      var loadCount = 0;
      var shaderPath = 'shaders/signDistance';
      var chunkPath  = 'shaders/shaderChunks/';
      var shaderLoader = new ShaderLoader( shaderPath , chunkPath );

      shaderLoader.endLoad = function(){
        loadCount ++;
        if( loadCount >= 3 ){
          init();
        }
      }
      
      shaderLoader.load( 'vs-text' , 'text'       , 'vertex'    );
      shaderLoader.load( 'fs-text' , 'text'       , 'fragment'  );
      shaderLoader.load( 'fs-sim'  , 'simulation' , 'fragment'  );


      function init(){

        var w = window.innerWidth;
        var h = window.innerHeight;

        clock = new THREE.Clock();

        camera = new THREE.PerspectiveCamera( 65 , w/h , 1 , 2000 );
        camera.position.z = 400;


        controls = new THREE.ScrollControls( camera );
        controls.scrollX = false;

        controls.upperY = 0;
        controls.lowerY = -4000;

        controls.dampening = .8;

        scene = new THREE.Scene();
         
        renderer = new THREE.WebGLRenderer();
        renderer.setSize( window.innerWidth, window.innerHeight );

        document.body.appendChild( renderer.domElement );
        window.addEventListener( 'resize', onResize , false );


        var vs  = shaderLoader.vertexShaders.text;
        var fs  = shaderLoader.fragmentShaders.text;
        var sim = shaderLoader.fragmentShaders.simulation;

        var creator = new TextParticles({
          vertexShader:   vs,
          fragmentShader: fs
        });
        
        vs_particles = creator.createTextParticles( vs );
        sim_particles = creator.createTextParticles( sim );
        fs_particles = creator.createTextParticles( fs );
        
        vs_particles.position.x = -350;
        vs_particles.position.y = 250;
        
        fs_particles.position.x = -350;
        fs_particles.position.y = -50;
        
        sim_particles.position.x = -350;
        sim_particles.position.y = -300;

        scene.add( vs_particles );
        scene.add( fs_particles );
        scene.add( sim_particles );


        var s = vs_particles.size;
        var simShader = shaderLoader.fragmentShaders.simulation;

        var speedUniform = { type:"v3" , value: camera.velocity }

        vsTextPosShader = new PhysicsRenderer( s , simShader , renderer );
        vsTextPosShader.setUniform( 't_to' , {
          type:"t",
          value:vs_particles.material.uniforms.t_lookup.value
        });

        vsTextPosShader.setUniform( 'speed' , speedUniform );
        vsTextPosShader.setUniform( 'timer' , timer );
        vs_particles.material.uniforms.t_lookup.value = vsTextPosShader.output;


        var s = fs_particles.size;
        var simShader = shaderLoader.fragmentShaders.simulation;

        fsTextPosShader = new PhysicsRenderer( s , simShader , renderer );
        fsTextPosShader.setUniform( 't_to' , {
          type:"t",
          value:fs_particles.material.uniforms.t_lookup.value
        });

        fsTextPosShader.setUniform( 'speed' , speedUniform );
        fsTextPosShader.setUniform( 'timer' , timer );
        fs_particles.material.uniforms.t_lookup.value = fsTextPosShader.output;


        var s = sim_particles.size;
        var simShader = shaderLoader.fragmentShaders.simulation;

        simTextPosShader = new PhysicsRenderer( s , simShader , renderer );
        simTextPosShader.setUniform( 't_to' , {
          type:"t",
          value:sim_particles.material.uniforms.t_lookup.value
        });

        simTextPosShader.setUniform( 'speed' , speedUniform );
        simTextPosShader.setUniform( 'timer' , timer );
        sim_particles.material.uniforms.t_lookup.value = simTextPosShader.output;

        // Get things rolling
        animate();
      
      }

      function animate(){

        timer.value += clock.getDelta();
        
        vsTextPosShader.update();
        vs_particles.material.uniforms.t_lookup.value = vsTextPosShader.output;

        fsTextPosShader.update();
        fs_particles.material.uniforms.t_lookup.value = fsTextPosShader.output;
         
        simTextPosShader.update();
        sim_particles.material.uniforms.t_lookup.value = simTextPosShader.output;

        requestAnimationFrame( animate );
        controls.update();
        renderer.render( scene , camera );
      }

      function onResize() {
        windowHalfX = window.innerWidth / 2;
        windowHalfY = window.innerHeight / 2;
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }
    </script>

  </body>
</html>
